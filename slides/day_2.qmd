---
title: "Day 2: Working with data"
subtitle: "Data wrangling"
format:
  revealjs:
    theme: dracula
    incremental: true
    transition: fade
    code-line-numbers: true
    self-contained: true
    embed-resources: true
#    include-in-header: fontawesome.html
---

## Notes

- After restarting R I need to run `library(dplyr)` (but not `library(palmerpenguins)`) to execute penguins %>% head(). Why is palmerpenguins loaded but not dplyr?


## Introduction - State of the data

"I have to admit, this [recording] is 80% me orienting to this week's data."
- LinkedIn, anon

"80% orienting to the data is real life!"
- Most of the comments section

## Learning objectives

- Understand what is meant by data wrangling.
- Learn the fundamentals of processing data and prepeparing data for analysis.
- Become comfortable with the main dplyr functions.
- Practice data wrangling.

## Data wrangling

"Data wrangling" refers to the process of taking messy, disorganised, or otherwise unready data and preparing it for downstream analysis. 

## Data wrangling

Common examples of data wrangling include:

- Renaming variables (columns) such that they all follow a convention (*e.g.,* from "win" and "Loss" to "W" and "L"). 
- Removing NAs.
- Ordering rows or columns (*e.g.,* to rank p.values or to sort samples alphabetically).
- Filtering (removing) rows or columns, either based on Boolean operators (*e.g.,* keep values > x, or < y) or to remove duplicates. 
- Calculating new, useful values (*e.g.,* success_rate = W/L). 

All of the above can be completed with a small number of functions from the dplyr package.

## The dplyr verbs

Functions for *rows*:

`arrange()`

`filter()`

`distinct()`

Functions for *columns*:

`relocate()`

`select()`

`rename()`

`mutate()`

## The dplyr verbs have functional names


`arrange()` and `relocate()` change the order of rows and columns.

`filter()` and `select()` keep or remove rows and columns.

`distinct()` returns only unique rows (removes duplicates).

`rename()` changes the name of a column.

`mutate()` creates a new variable based on one or more other columns.

## (Re)arranging the order

The `arrange()` function (for rows) and the `relocate()` function (for columns) allow us to re-order our data.

## `arrange()` the rows

```{r}
library(tidyverse)
library(palmerpenguins)
```

Start by looking at our data:
```{r}
#| echo: true
penguins %>% head()
```

#

```{r}
#| echo: true
penguins %>% tail()
```

## `arrange()` the rows {.smaller}
```{r}
#| echo: true

penguins %>% arrange(body_mass_g) %>% head()
```

#

```{r}
#| echo: true
penguins %>% arrange(desc(body_mass_g)) %>% head()
```

## `arrange()` the rows {.smaller}
```{r}
#| echo: true

# Penguin body mass by year
penguins %>% arrange(desc(year),desc(body_mass_g)) %>% head()
```
*Note* you can apply `desc()` to any number of arguments within `arrange()`, but you must apply `desc()` to each variable individually.

Combining arguments within the `arrange()` function can be used for splitting ties (*e.g.,* when you have samples with year, month and date recorded). 

## `relocate()` the columns

Change the order of columns with `relocate()`. 

`relocate()` takes a column name and moves it to another position in the dataset, defaulting to moving the specified column to the start (left) of the dataset. 


```{r}
#| echo: true

penguins %>% relocate(year) %>% head()
```

## `relocate()` the columns

We can choose to place a column immediately before, or immediately after, another column.

\

```{r}
#| echo: true

penguins %>% relocate(year, .after = island) %>% head()
```

## (Re)arranging summary

Remember: a**rr**ange is for **r**ows, while sele*c*t is for *c*olumns.

`arrange()` is functionally sorting rows, while `select()` is a manual re-organising of columns. 

\

**Reminder:** none of our functions are modifying the original dataset. Re-arranged data is only being displayed on the screen. Save the output of these functions to a new object if you want to store data. 

## It's your turn! {.slide-practical}

### Exercise 1 

*Update this to something different*

Task: understand what happened to the NAs in our dataset when we ran arrange().

-   Use the `summary()` function and read the output to identify how many rows have NAs.
-   Why is this an imperfect method? What does `summary()` *not* tell us in this case?

-   Use the `count()` function to check how many rows are in the penguins dataset.
-   Use 

:::{.Large}
```         

```
:::



## Keeping or removing data

The next two functions are `filter()` (for rows) and `select()` (for columns). 

In both cases we will specify which data to keep and the rest will be discarded. 

As above, we can use the **r** in filte**r** and the *c* in sele*c*t to help us remember which function is **r**ows and which is for *c*olumns. 

## `filter()` with single criteria

Keep all rows that meet a certain criteria in a given column. Criteria can be built using any combination of Boolean values (greater than, less than or equal to, exactly equal to) using "and" or "or".
- *e.g.,* keep any row if the value is greater than 1 or less than -1

```{r}
#| echo: true

penguins %>% filter(body_mass_g > 4000) %>% head()
```
```{r}
#| echo: true

penguins %>% filter(body_mass_g > 4000) %>% count()
```

## Filter criteria

**Add a table of the criteria (>, <, >=, ==)**

## `filter()` with and/or
```{r}
#| echo: true

penguins %>% filter(species == "Gentoo" & bill_length_mm > 50) %>% count()
# 22 Gentoo samples have a bill length greater than 50.
```

\

```{r}
#| echo: true

penguins %>% filter(species == "Gentoo" | island == "Biscoe") %>% count()
# 168 samples are either Gentoo species OR are found on the Biscoe island. 
```

## `select()` the columns to keep

`select()` defines which columns are kept.
```{r}
#| echo: true

penguins %>% select(species, island) %>% head(n = 4)
```

\

```{r}
#| echo: true

penguins %>% select(bill_length_mm:body_mass_g) %>% head(n = 4)
```

## `select()` advanced usage

Here we will demonstrate a powerful feature of programming languages: the ability to perform pattern matching. Pattern matching is not covered in this course, but consider this a gentle introduction to the concept.

\

Instead of needing to select individual variables we can select variables that meet a criteria, such as "starts with the letter b" or "contains an _". 

## `select()` advanced usage

```{r}
#| echo: true

penguins %>% select(starts_with("bill")) %>% head(n = 4)
```
\
```{r}
#| echo: true

penguins %>% select(ends_with("s")) %>% head(n = 4)
```

## `select()` advanced usage

```{r}
#| echo: true

penguins %>% select(contains("_")) %>% head(n = 4)
```
\
```{r}
#| echo: true

penguins %>% select(!species) %>% head(n = 4)
# Do NOT select species, but keep everything else.
# Use `!contains()` to exclude variables containing a specific pattern.
```

## It's your turn! {.slide-practical}

### Exercise 2 

This exercise will reinforce your understanding of combining arguments.

Use `select()` and `starts_with()` to keep all columns that measure a physical feature of the penguins (bill_lenth_mm, bill_depth_mm, flipper_lenth_mm, body_mass_g). 


:::{.Large}
```         
Code we have used today which might help:

select(starts_with("bill"))

filter(species == "Gentoo" | island == "Biscoe")
```
:::

## Solution

You may have tried this:

**penguins %>% select(starts_with("b" | "f")) %>% head()**


We need to specify `starts_with()` for each criteria individually. We used this same logic earlier when we used `arrange(desc(year),desc(body_mass))`.

```{r}
penguins %>% select(starts_with("b") | starts_with("f")) %>% head()
```

## Understanding the solution

\

This gives us more precise control over our criteria. 

*e.g.,* what if you needed to specify **starts with** b or **ends with** f?

:::{.notes}
Initially, `starts_with("b" | "f")` seems logical. It sounds right: "Starts with b or f". However, when we imagine a more complex example, like if we needed to specify starts with b or ends with f, or starts with A and contains an underscore, we can see it is logical to specify each criteria individually.

:::

## `distinct()` to remove duplicate rows

The distinct function will remove rows that have the same value for a selected criteria.

```{r}
#| echo: true

penguins %>% distinct(year) %>% head()
# All duplicates of "2007", "2008", "2009" have been removed.
```

#

Useful when looking for unique *combinations*:
```{r}
#| echo: true

penguins %>% distinct(species, island) %>% head()
```

\ 

Reveals Adelie penguins are found on all three islands, while Gentoo and Chinstrap are restricted to Biscoe and Dream, respectively.

## `mutate()` calculates new variables

`mutate()` takes information from one or more columns and creates a new variable which is immediately added to the object. 

```{r}
#| echo: true

penguins %>% 
  mutate(bill_dim_ratio = bill_length_mm / bill_depth_mm) %>% 
  arrange(desc(bill_dim_ratio)) %>% 
  select(contains("_")) %>% 
  head()
```

:::{.notes}
`mutate()` has calculated a new variable called bill_dim_ratio (bill dimension ratio) based on the formula we provided and data from those variables. 

Data has been arranged based on this new variable (note, it's immediately available, you don't have to ouput this data somewhere before you can interact with the new variable.)

`select()` used to reduce the number of columns on the screen.
:::

## `rename()` columns

`rename()` renames variables. Keep variable names short, descriptive, and uniform.

Develop a system and be consistent.

- some_people_like_snake_case

- otherPeoplePreferCamelCase

#

```{r}
#| echo: true

penguins %>% rename(flipLength = flipper_length_mm) %>% head()
```

## `group_by()` and `summarize()` ???

Include group_by() and summarize()?


## A preview of tomorrow

```{r}
#| echo: true
#| eval: false

ggplot(
  data = penguins,
  mapping = aes(x = bill_length_mm,
                y = bill_depth_mm,
                shape = island, 
                colour = species)) +
  geom_point()
```

#


```{r}
#| echo: false
#| eval: true

ggplot(
  data = penguins,
  mapping = aes(x = bill_length_mm,
                y = bill_depth_mm,
                shape = island, 
                colour = species)) +
  geom_point()
```

:::{.notes}
With just a few lines of code we can produce a plot like this. Cool, right??? 
No! This is a hideous, terrible plot that should never be seen in public. I mean, it's fine if I want to check something quickly, but look at it. No title, ugly axis labels, horrible colour scheme. Tomorrow, we will learn how to make plots to be proud of. 
:::



