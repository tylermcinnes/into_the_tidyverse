---
title: "Day 3: Importing and Visualising data"
subtitle: "From raw data to presentable figure"
format:
  revealjs:
    theme: dracula
    incremental: true
    transition: fade
    code-line-numbers: true
    self-contained: true
    embed-resources: true
#    include-in-header: fontawesome.html

---



## Introduction

In this session we will learn how to visualise data using the ggplot2 package.

Importing, data wrangling, and data visualisation constitute a large part of the work you will do in bioinformatics. Today's session will be a 'full workflow'. 

## Learning Objectives

- Learn how to import data in R with the readr package.
- Visualise data with ggplot2.
- Become familiar with the `ggplot()` function format.
- Use a range of geoms to plot different types of data.
- Practice writing tidy code.
- Practice key skills from day 1 and day 2. 





## Importing with readr {.smaller}

The readr package is part of the tidyverse.

We can use the `read_csv()` function to import a csv file into R.

```{r}
#| echo: true


library(tidyverse)

penguin_data <- read_csv("../data/penguin_dataset.csv")
```



`summary()` evaluates each column and returns a summary depending on the type of data. For columns of numeric data we see mean, median, min, max and quartile information. 
For character columns we see the length, and for logical columns we get a count of the number of TRUE and FALSE calls. 

`summary()` is a useful function to understand the shape of your data.




## Importing ugly data {.smaller}

We will often encounter data that does not match our expectations for clean and tidy column names. 

Go to https://tinyurl.com/uglyDuckling2025 and use the download button to download this example dataset. 

Store it in your `/data` directory. 

\

```{r}
#| echo: true


uglyDuckling_data <- read_csv("../data/uglyDuckling_dataset.csv")
uglyDuckling_data |> colnames()
```

\

snake_case, camelCase, **and** spaces??? Who made this object!? 

## Renaming our ugly data

```{r}
#| echo: true
#| 
ugly_duckling_data <- uglyDuckling_data |> rename(
  species = "Species",
  bill_length_mm = "billLengthMM",
  flipper_length_mm = "Flipper_length_mm",
  body_mass_g = "body mass g",
  year = "Year"
)

ugly_duckling_data |> colnames()
```

## What if I had a lot of columns?

```{r}
#| echo: true
#| eval: false

install.packages("janitor")
```


```{r}
#| echo: true
#| eval: false
library(janitor)

uglyDuckling_data |> janitor::clean_names()
```

The [janitor](https://sfirke.github.io/janitor/) R package has a lot of useful tools for cleaning data. 

Remember, there are functions and packages for *so many* tasks. Search for existing packages to make your tasks easier.

::: {.notes}

It's functional to rename a small number of columns manually with `rename()`, but for many column names, use `clean_names()` from the janitor package.

Remember, there are functions and packages for *so many* tasks - look for them.

:::


## Importing other data types

Other functions exist for other data:

`read_tsv()` for tab-delimited files. 

`read_table()` for files where columns are separated by white space.

`read_delim()` reads in files and guesses what the correct delimiter is. Use in cases where you don't know what the type of data coming in is. 


## Data visualisation with ggplot 

\

- ggplot ("Grammar of Graphics"): work iteratively, build complexity. 

- Focus on the format.

- Demonstrates a key loop in data analysis: visualise your data, make adjustments, transform the data and visualise again. 


## The ggplot format

The ggplot format has **three parts**:

Calling the *ggplot function and specifying the data*.

*Mapping* the data: what data is displayed on the x and y axis.

*Plotting the data* with a geom function - there are different geoms for different types of plots. 

  - Note that the geom is a new function, which means we need to add a "+" to the previous line.



## The ggplot format

```{r}
#| echo: true
#| fig-align: center

ggplot(data = penguin_data,
       mapping = aes(x = flipper_length_mm,
                     y = body_mass_g)) +
  geom_point()
```




## Improving the visualisation

There are many steps we can take to improve our initial visualisation. 

Here we will:

- Add titles and labels

- Improve the visual theme

- Re-order the data to reduce cognitive load

- Layer multiple geoms

- Use geom arguments to change the look of the figure


## Titles, labels and theme

(Boring, but necessary)

Add title and labels with the `labs()` function.

Themes control the look of the plot window. Try `theme_minimal()`, `theme_dark()`, `theme_bw()`, and many others, for different looks. 

\

- Each new function is preceeded by a "+" on the previous line.

## Titles, labels and theme

```{r}
#| echo: true
#| fig-align: center

ggplot(data = penguin_data,
       mapping = aes(x = bill_length_mm,
                     y = bill_depth_mm)) +
  labs(title = "Bill length and depth in penguins",
       x = "Bill length (mm)",
       y = "Bill depth (mm)") +
  theme_minimal() +
  geom_point()
```



## Mapping additional variables

*mapping = aes()* is used to map a variable to an axis. 

Variables can also be mapped to axes other than x and y:

*Colour*, *size*, and *shape* are all axes we can map aesthetics to. 


## Mapping additional variables

```{r}
#| echo: true
#| eval: false


ggplot(data = penguin_data,
       mapping = aes(x = bill_length_mm,
                     y = bill_depth_mm,
                     colour = species)) +
    labs(title = "Bill length and depth in penguins",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       colour = "Species") +
  theme_minimal() +
  geom_point()
```


#

```{r}
ggplot(data = penguin_data,
       mapping = aes(x = bill_length_mm,
                     y = bill_depth_mm,
                     colour = species)) +
    labs(title = "Bill length and depth in penguins",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       colour = "Species") +
  theme_minimal() +
  geom_point()
```

## Arguments for fine control

Place arguments within the `geom_` you want to control, or within `theme()` for overall visuals.


```{r}
#| echo: true
#| eval: false


ggplot(data = penguin_data,
       mapping = aes(x = bill_length_mm,
                     y = bill_depth_mm,
                     colour = species)) +
    labs(title = "Bill length and depth in penguins",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       colour = "Species") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold")) +
  geom_point(size = 3,
             alpha = 0.6)
```


#

```{r}
#| echo: false
#| eval: true


ggplot(data = penguin_data,
       mapping = aes(x = bill_length_mm,
                     y = bill_depth_mm,
                     colour = species)) +
    labs(title = "Bill length and depth in three species of penguin",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       colour = "Species") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold")) +
  geom_point(size = 3,
             alpha = 0.6)
```

## Complex arguments for `geom_point()`

```{r}
ggplot(data = penguin_data,
       mapping = aes(x = bill_length_mm,
                     y = bill_depth_mm,
                     colour = body_mass_g,
                     shape = species)) +
    labs(title = "Bill length and depth in three species of penguin",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       colour = "Body mass") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold")) +
  geom_point(size = 3,
             alpha = 0.6)
```


## It's your turn! {.slide-practical}

### Exercise 3

How was this plot created? Use code from the previous slides and modify it yourself to duplicate this plot. 

```{r}
#| fig-align: center
#| 
ggplot(data = penguin_data,
       mapping = aes(x = bill_length_mm,
                     y = bill_depth_mm,
                     colour = body_mass_g,
                     shape = species)) +
    labs(title = "Bill length and depth in three species of penguin",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       colour = "Body mass") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold")) +
  geom_point(size = 3,
             alpha = 0.6)
```

## Solution and explanation

```{r}
#| fig-align: center
#| echo: true
#| 
ggplot(data = penguin_data,
       mapping = aes(x = bill_length_mm,
                     y = bill_depth_mm,
                     colour = body_mass_g,
                     shape = species)) +
    labs(title = "Bill length and depth in three species of penguin",
       x = "Bill length (mm)",
       y = "Bill depth (mm)",
       colour = "Body mass") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold")) +
  geom_point(size = 3,
             alpha = 0.6)
```

::: {.notes}
The key point here is that we are able to set aesthetics like colour and size to be variables, rather than fixed values. Think about how we can use this: *e.g.,* varing the size of a data point based on how many samples it represents, or varying the colour of a point based on how significantly different it is. You could, for example, colour all the points on a volcano plot based on p.values - however, I think the best use of this is to use a value like colour or shape to represent a value that is *not* represented by the x or y axis (so, colouring points on the volcano plot based on p.value is redundant). 

Want to focus on the balance of **information density**: x, y, colour, size, and shape make five axes on which to convey information. However, this can be overwhelming. 

Note that for aesthetics like colour, there are an almost endless variety of colours, so useful for numeric values. There are not so many shapes, so reserve shapes for discrete variables like sex, gender, or populations. 
:::

## Writing in a shorter format

Because "data =" and "mapping =" are fundamental arguments, these can be shortened:

```{r}
#| echo: true
#| eval: false

ggplot(data = penguin_data,
       mapping = aes(x = flipper_length_mm,
                     y = flipper_depth_mm)) +
      geom_point()

```

Is the same as:

```{r}
#| echo: true
#| eval: false

ggplot(penguin_data,
       aes(x = flipper_length_mm,
           y = flipper_depth_mm)) +
  geom_point()
```

## Storing plot information

We can save plot information as an object.

Store mapping, theme, and other options.  

Combine plot object with different geoms.

```{r}
#| echo: true
#| 
p_flipper_length <- ggplot(data = penguin_data,
       mapping = aes(x = species,
                     y = flipper_length_mm)) +
    labs(title = "Flipper length of penguins",
       x = "Species",
       y = "Flipper length (mm)") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold"))
```

## Plot objects

```{r}
#| echo: true

p_flipper_length
```

::: {.notes}
This demonstrates the iterative process of ggplot. Currently our p_flipper_length object has the mapping aesthetics, theme, title information etc.,. 

Then we can *layer* a geom over the top. This is key: we are going to layer geoms. 
:::

## Plot objects

```{r}
#| echo: true

p_flipper_length +
  geom_boxplot()
```

## Plot objects

```{r}
#| echo: true

p_flipper_length +
  geom_boxplot() +
  geom_jitter()
```

::: {.notes}
We have now layered geom_jitter on top of the boxplot. While the result is ugly, we can hopefully see the application. This is both a fundamentally important point for *understanding* ggplot and a practical skill: by layering geoms we can generate complex, detailed plots. 
:::

## Combining geoms

```{r}
#| echo: true
#| fig-align: center
#| 
p_flipper_length +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(size = 3,
              width = 0.25,
              alpha = 0.5)
```

## Adding variables as arguments from here

I can map variables such as species or island to the data points in geom_jitter.

Because these were not mapped in p_flipper_length, I have to use *mapping = aes()* to connect a variable to an aesthetic.

```{r}
#| echo: true
#| eval: false
#| 
p_flipper_length +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(mapping = aes(colour = species),
              size = 3,
              width = 0.25,
              alpha = 0.5)
```

#

```{r}
#| echo: true
#| fig-align: center
#| 
p_flipper_length +
  geom_boxplot(outlier.alpha = 0) +
  geom_jitter(mapping = aes(colour = species),
              size = 3,
              width = 0.25,
              alpha = 0.5)
```

Use `aes()` when specifying data that is coming from an object. 

# Short break

# Recap {.smaller}

How do we import data?

- `read_csv()`, `read_delim()`

What functions can we use to initially look at our data?

- `head()`, `tail()`, `glimpse()`, `class()`, `str()`, and `summary()`

What are the three parts of a ggplot codeblock?

- `ggplot()`, mapping = `aes()`, and `geom_X()`

How do we control titles, labels, and legends?

- `labs()` to add text, `theme()` to control text features


## Facets and combining plots

Using `facet_wrap()` and `facet_grid()` we can split data across multiple plots.

  Patterns can become clearer when data is split. 

\

We can combine discrete plots together into a figure with the patchwork and cowplot libraries. 

  Join data from multiple sources to tell a cohesive story.
  

## `facet_wrap()` and `facet_grid()`

`facet_wrap()` splits data according to a single variable (*e.g.,* split samples by sex).

`facet_grid()` splits data according to two variables (*e.g.,* split samples by age group and treatment group).

## Preparing the data

```{r}
#| echo: true

p_bm_fl <- ggplot(data = penguin_data,
                  mapping = aes(x = body_mass_g,
                                y = flipper_length_mm,
                                colour = species))
```


## Example with `facet_wrap()`

```{r}
#| echo: true
#| eval: false
p_bm_fl +
  geom_point(size = 2,
             alpha = 0.6) +
  facet_wrap(~ island)
```

#

```{r}
#| echo: false
#| fig-align: center
p_bm_fl +
  geom_point(size = 2,
             alpha = 0.6) +
  facet_wrap(~ island)
```

## Example with `facet_grid()`

```{r}
#| echo: true
#| eval: false

p_bm_fl +
  geom_point(size = 2,
             alpha = 0.6) +
  facet_wrap(island ~ sex)           
```

#

```{r}
#| echo: true
#| fig-align: center

p_bm_fl +
  geom_point(size = 2,
             alpha = 0.6) +
  facet_wrap(sex ~ island)           
```

::: {.notes}
It might be more interesting to actually use facet_wrap with island and species, and use colour (or shape) for sex. 
:::


## Combining plots into a single image

Two packages, patchwork and cowplot, provide the ability to combine plots.

```{r}
#| echo: true
#| eval: false
install.packages("patchwork")
```

```{r}
#| echo: true

library(patchwork)
```


## patchwork requires stored plots

Make two plots.

```{r}
#| echo: true
#| 
p1 <- ggplot(penguin_data,
              aes(x = bill_depth_mm,
                  y = bill_length_mm,
                  colour = species)) +
      geom_point() +
      labs(title = "Flipper length and depth",
           x = "Bill depth (mm)",
           y = "Bill length (mm)")

p2 <- p_bm_fl +
      labs(title = "Body mass and flipper length",
           x = "Flipper length (mm)",
           y = "Body mass (g)") +
      geom_point() 
```

## Combining plots with patchwork

Combine p1 and p2 with 'arithmetic' operators:

```{r}
#| echo: true
#| fig-align: center

p1 + p2
```

#
 
```{r}
#| echo: true
#| fig-align: center

p1 / p2
```




## Adding trendlines (an aside)

```{r}
#| echo: true
#| eval: false
p_bm_fl +
  geom_point(size = 2,
             alpha = 0.6) +
  facet_wrap(~ island) +
  geom_smooth(
    mapping = aes(group = island),
    method = "lm",
    colour = "darkgrey")
```

# Adding trendlines

```{r}
#| echo: true
#| fig-align: center
#| 
p_bm_fl +
  geom_point(size = 2,
             alpha = 0.6) +
  facet_wrap(~ island) +
  geom_smooth(
    mapping = aes(group = island),
    method = "lm",
    colour = "darkgrey")
```


## Visualising correlation with `geom_tile()`

Heatmaps are a useful way to visualise values across two dimensions using colour. Examples from biology are expression values for a given set of genes across samples. 

This is often combined with clustering (*e.g.,* unsupervised clustering with k-means) to identify patterns which differ between groups. 

Here we will create a simple supervised tile heatmap.

## Generating some example data {.smaller}

Here we will generate some example data showing some value (counts, words written, tasks completed *etc.,*) per day for five weeks.

```{r}
#| echo: true

set.seed(0982)
month_data <- tibble(
  date = seq(as.Date("2024-12-01"), 
              as.Date("2024-12-31"), 
              by = "day"),
  count = sample(1:20, 31, replace = TRUE)  # Random counts per day
) |>
  mutate(
    wday = wday(date, label = TRUE, abbr = TRUE),  # Day of the week (Sun-Sat)
    week = (day(date) - 1) %/% 7 + 1  # Week number (1 to 5)
  )

month_data |> head()  
```

## Starting with `geom_tile()` {.smaller}

```{r}
#| echo: true
#| fig-align: center

ggplot(data = month_data,
       mapping = aes(x = week, 
                      y = wday, 
                      fill = count)) +
  geom_tile()
```

What are the issues with this plot? 


## Improving `geom_tile()`

We need to: 

- Change the x and y axis (putting days the y).

- Invert the order of days (use the `scale_y_reverse()` function).

- Use `labs()` to add a title, axis labels and rename the fill (legend) variable. 

- Additionally, adding colour = "white" as an argument for `geom_tile()` will add separation between grid points. 

## Solution

```{r}
#| echo: true
#| eval: false

ggplot(data = month_data,
       mapping = aes(x = wday,
                     y = week,
                     fill = count)) +
  geom_tile(colour = "white") +
  scale_y_reverse() +
  theme_classic() + # removes background gridlines
  labs(title = "December 2024 Calendar Heatmap",
       x = "Week",
       y = "Day of the week",
       fill = "Count")
```

## Solution

```{r}
#| echo: false
#| eval: true

ggplot(data = month_data,
       mapping = aes(x = wday,
                     y = week,
                     fill = count)) +
  geom_tile(colour = "white") +
  scale_y_reverse() +
  theme_classic() +
  labs(title = "December 2024 Calendar Heatmap",
       x = "Week",
       y = "Day of the week",
       fill = "Count")
```

## Visualising change over time (line plots)

```{r}
#| echo: true

set.seed(02) # Please set this seed for this example

# Create stock price data for three different stocks
dates <- seq.Date(from = as.Date("2024-01-01"), 
                  by = "week", 
                  length.out = 200)

stocks <- tibble(
  date = rep(dates, times = 3),
  stock = rep(c("Stock A", "Stock B", "Stock C"), each = length(dates)),
  price = c(
    100 + cumsum(rnorm(length(dates), mean = 0, sd = 5)),  # Stock A fluctuates around 100
    80 + cumsum(rnorm(length(dates), mean = 0, sd = 4)),   # Stock B fluctuates around 80
    120 + cumsum(rnorm(length(dates), mean = 0, sd = 6))   # Stock C fluctuates around 120
  )
)
```

## Line chart with `geom_line()`

```{r}
#| echo: true
#| fig-align: center

ggplot(stocks %>% filter(stock == "Stock C"), 
        aes(x = date, 
            y = price)) +
  geom_line() +
  labs(title = "Stock C Price Over Time", 
        x = "Date", 
        y = "Price") +
  theme_minimal()
```

## Combining `geom_line()` and `geom_fill()` {.smaller}

`geom_area()` adds a filled or shaded area. The plot looks much less empty.

```{r}
#| echo: true
#| fig-align: center

ggplot(stocks %>% filter(stock == "Stock B"), 
        aes(x = date, y = price)) +
  geom_area(fill = "black", 
            alpha = 0.4) +
  geom_line(color = "black", 
            linewidth = 0.5) +  # Keeps the line for clarity
  labs(title = "Stock B Price Over Time (Area Chart)", 
        x = "Date", 
        y = "Price") +
  theme_minimal()
```

## A popular option: the stacked area chart

Look at this example from an excellent data visualiser [CÃ©dric Scherer:](https://www.cedricscherer.com/tags/ggplot2/):

  ![](../img/day_3/CedricScherer_stackedAreaPlot.png)
  
  
## Creating a stacked area chart

```{r}
#| echo: true
#| fig-align: center

ggplot(stocks, aes(x = date, 
                    y = price, 
                    fill = stock)) +
  geom_area(alpha = 0.6) +  # Fill areas with transparency
  labs(title = "Stacked Area Chart of Stock Prices Over Time",
       x = "Date", 
       y = "Price", 
       fill = "Stock") +
  theme_minimal()
```

## Critically analysing our stocks {.smaller}

```{r}
#| echo: false
#| fig-align: center

ggplot(stocks, aes(x = date, 
                    y = price, 
                    fill = stock)) +
  geom_area(alpha = 0.6) +  # Fill areas with transparency
  labs(title = "Stacked Area Chart of Stock Prices Over Time",
       x = "Date", 
       y = "Price", 
       fill = "Stock") +
  theme_minimal()
```

What is happening with our stock values?

- Stock B and C are increasing over time. However, Stock A is not changing. 

- It is difficult to accurately estimate Stock A's change in value over time because of the stacked nature of the plot. 

- We recommend you do not use stacked area plots, despite their popularity.

## Recommended break time

The remainder of this workshop is a walkthrough of a real data visualisation. 

## Start to finish visualisation with tidytuesday

[tidytuesday](https://github.com/rfordatascience/tidytuesday) is a community initiative that publishes a weekly dataset in an easy-to-access format. Each week, people create a visualisation using the shared dataset and publish it on social media. 

In 2024, tidytuesday had the aim of being featured in 10+ training courses. They hit more than 30!

In this section we will walk through a real data visualisation: importing the data from an online repo, carrying out exploratory analysis, data wrangling, visualisation, more data wrangling, and a final visualisation.

## Import the tidytuesday data and exploratory analysis

```{r}
#| echo: true


parfumo_data_clean <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2024/2024-12-10/parfumo_data_clean.csv')
```

## Exploratory analysis

Use functions we have covered in this workshop to explore the data. Note down your initial conclusions and impressions. 

Specifically: 

- What are five things you notice about the data?

- What is one question you have about the data?

- What is something you might want to investigate, visualise or learn about? 

## Exploratory analysis initial conclusions {.smaller}

- The data has a lot of NAs. Concentration is almost 80% NA, Rating_Count is almost 50% NA.

- There is a mix of nmeric and character data.

- Rating_Value looks like it's a 0-10 scale, with a mean and median around 7.3 - 7.4

- The mean and median of Rating_Count vary significantly: median of 19 and a mean of 60.

- The basic structure: perfume name, brand, then values and descriptions. 

- *Questions and assumptions*: I assume Rating_Value is an average, with Rating_Count describing how many Ratings contributed to this value.

## Brand, Rating_Value, and Rating_Count

*Aim:* generate a visualisation which will show which brands consistently have high ratings for their different products, with the intention that a person with little to no knowledge about perfume (like myself) can get an idea of reliable brands.

\

**Exercise:** Mentally visualise what this figure might look like. What are the key components we will need to convey?

## Assessing the means {.smaller}

```{r}
#| echo: true

parfumo_data_clean |> 
  group_by(Brand) |> 
  summarize(avg_Rating = mean(Rating_Value, na.rm = TRUE)) |> 
  arrange(desc(avg_Rating)) |> 
  head()
```

\

Does this mean Natura and Sarahs Creations are the best choice? Why?

- Does `summary()` change your opinion?

## Hypothesis

Hypothesis: some brands have very high average ratings but this is an artifact due to low sampling numbers. 

*i.e.,* Brands with more ratings are (unfairly) penalised as their average ratings are pulled downwards by individual preferences. Natura and Sarahs Creations were possibly rated by 1 - 2 people who scored the perfumes with 10s. 

- How can we test this hypothesis with a visualisation? 

## Perfumes with fewer ratings have high variation in rating value {.smaller}

```{r}
#| echo: true
#| fig-align: center

ggplot(data = parfumo_data_clean, 
      mapping = aes(x = Rating_Count, 
                    y = Rating_Value)) +
  geom_point()
```

- Comment on the fact that there are no perfumes with more than 1000 ratings and a rating of less than 5. What could cause this? 

## An aside: being aware of other relationships {.smaller}

*Hypothesis:* There will be a significant relationship between Rating_Count and Release_Year.

```{r}
#| echo: true
#| fig-align: center
#| warnings: false

ggplot(data = parfumo_data_clean, 
        mapping = aes(x = Release_Year, y = Rating_Count)) +
  geom_point()
```

- This is important because if we are filtering based on a Rating_Count threshold, we need to be aware this is reducing the likelihood of older Brands appearing.

- *note*: I have suppressed the warnings about NAs, and will continue to do so for all future plots. 

## Ready to wrangle {.smaller}

At this point I have performed a basic exploratory analysis. I believe I understand the basics of my data and I'm ready to begin data wrangling.

For each of the data wrangling steps we will discuss the logic.

**Data wrangling steps**

- *Filtering for low rating counts:* Perfumes that were rated fewer than 19 times (the median number of ratings) were removed from the data. Having a small number of ratings can skew the rating result (e.g., a single 10/10 is not representative of the perfumes quality).

- *Calculate the average rating by brand and the number of perfumes per brand:* Perfumes were grouped by brand, and the average (mean) rating for each brand was calculated. Some brands had only a small number of perfumes, which led to skewed averages.

## Data wrangling cont. {.smaller}

- *Remove brands with a small number of perfumes:* Brands with fewer than 20 perfumes were removed from the analysis.

- *Store the perfume_brand_data object:* A dataframe of 1635 rows, consisting of only perfumes that meet the above two criteria (individually rated more than 19 times, and from a brand with 20 or more perfumes).

- *Create and store the brandRatingData object:* A dataframe of 20 rows and three variables, consisting of the 20 brands with the highest average rating (the mean rating across all perfumes for the brand), as well as the number of perfumes in each brand.

## Explore the new objects

```{r}
#| echo: true

perfume_brand_data <- read.csv('https://raw.githubusercontent.com/tylermcinnes/visualization_day/refs/heads/main/data/perfume_brand_data.csv')

brandRatingData <- read.csv('https://raw.githubusercontent.com/tylermcinnes/visualization_day/refs/heads/main/data/brandRatingData.csv')
```

## Explore the new objects

```{r}
#| echo: true

perfume_brand_data |> head()

perfume_brand_data |> colnames()
```

## Explore the new objects

```{r}
#| echo: true

brandRatingData |> head()
```


## Building a visualisation - sketching

```{r}
#| echo: true
#| fig-align: center

ggplot(data = perfume_brand_data,
       mapping = aes(x = Rating_Value, 
                      y = Brand)) +
  geom_boxplot()
```

## "Sketching" options

ggplot allows us to make quick plots to visualise data. For a complex task, it's recommended to try different geoms and formats, experimenting with mappings to identify the clearest way to represent the data. 

In this example I eventually discarded the boxplot. I could not see an easy way to represent the number of perfumes per brand, nor the number of ratings per perfume, and I felt this was important data. 

## `geom_point` and the brand rating average

```{r}
#| echo: true
#| eval: false
#| fig-align: center

ggplot(brandRatingData, 
       aes(
        x = avg_Rating,
        y = reorder(Brand, avg_Rating))) +
  geom_point(aes(
    size = number_Perfumes,
    color = avg_Rating)) +
  labs(
    x = "Brand rating",
    y = "Brand",
    title = "Mean perfume rating by brand"
  ) 
```

## `geom_point` and the brand rating average

```{r}
#| echo: false
#| eval: true
#| fig-align: center

ggplot(brandRatingData, 
       aes(
        x = avg_Rating,
        y = reorder(Brand, avg_Rating))) +
  geom_point(aes(
    size = number_Perfumes,
    color = avg_Rating)) +
  labs(
    x = "Brand rating",
    y = "Brand",
    title = "Mean perfume rating by brand"
  ) 
```

## Refining the plot {.smaller}

```{r}
#| echo: true
#| 
brandRatingData <- parfumo_data_clean |> 
  filter(Rating_Count >= 19 ) |> 
  group_by(Brand) |> 
  summarize(avg_Rating = mean(Rating_Value, na.rm = TRUE),
            number_Perfumes = n(),
            avg_rating_count = mean(Rating_Count)) |> 
  filter(number_Perfumes >= 20) |> 
  arrange(desc(avg_Rating)) |> 
  head(n = 20)
```

Currently, colour is not being fully utilised - it is mapped to the Brand average rating, which is already shown via the x axis. Thinking back to earlier themes on number of ratings and number of perfumes per brand, we could use colour to represent some of our data around the rating_Count variable.

To do this, we will re-build the brandRatingData object with an additional variable calculated by the summarize() function, calling it avg_rating_count and then map it to colour.

## Refined

```{r}
ggplot(brandRatingData, 
       aes(x = avg_Rating, y = reorder(Brand, avg_Rating))) +
  geom_point(aes(size = number_Perfumes, color = avg_rating_count)) +
  scale_size(range = c(1, 10), name = "Number of perfumes") +
  labs(
    x = "Brand rating",
    y = "Brand",
    title = "Top 20 Perfume Brands Ranked by Mean Rating"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10, color = "gray40"),
    axis.title = element_text(size = 12, face = "bold", color = "gray50"),
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5, color = "gray50"),
    legend.title = element_text(size = 12, face = "bold", color = "gray50"), 
    legend.text = element_text(size = 10, color = "gray40")
  ) 
```


## Summary

ggplot has fine control over all elements of the plot window.

Combine geoms, separate data with `facet()`, join figures with patchwork.

ggplot facilitates exploratory data analysis with quick plots.

dplyr verbs can manage majority of data wrangling.

Plot, transform, plot with refined features.
